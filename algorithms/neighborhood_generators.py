'''
This module contains functions to generate neighborhoods for the Traveling Salesman Problem (TSP) using different techniques such as swap and 2-opt moves. 
The module provides functions to generate all possible neighbors as well as single neighbors by performing specific moves on the given path.
Functions:
    swap_neighborhood(path, print_neighbors=False):
        Generates all possible neighbors of a path by swapping two nodes.
    two_opt_neighborhood(path, print_neighbors=False):
        Generates the 2-opt neighborhood for a given path in the TSP by reversing the order of nodes between two indices.
    two_opt_single_neighbor(path):
        Generates a single neighbor of the given path using the 2-opt algorithm by reversing the order of nodes between two randomly selected indices.
    swap_single_neighbor(path):
        Generates a single neighbor of the given path by swapping two randomly selected nodes.
Usage:
    The functions in this module can be used to explore the neighborhood of a given solution in the TSP.
    Example:
        python neighborhood_generators
    This will test the neighborhood generation functions by generating neighbors for a sample path ([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 0]) using both swap and 2-opt moves.
    
'''
import random

from ..utils.path_utils import print_in_square

def swap_neighborhood(path, print_neighbors=False):
    """
    Generate all possible neighbors of a path by swapping two nodes.
    
    Args:
        path (list): The current path (a list of node indices).
    
    Returns:
        list: A list of paths, each created by swapping two nodes in the original path.
    """
    neighbors = []
    n = len(path)
    
    # For each pair of nodes (i, j), perform a swap
    for i in range(1, n - 1):        # Avoid swapping the start and end nodes (0 and last)
        for j in range(i + 1, n - 1):
            # Create a copy of the path to avoid modifying the original
            new_path = path[:]
            # Perform the swap
            new_path[i], new_path[j] = new_path[j], new_path[i]
            # Add the new path to the neighborhood
            neighbors.append(new_path)
    if print_neighbors:
        print_in_square("Path", path)
        print("Swap Neighborhood:")
        for neighbor in neighbors:
            print(neighbor)
    return neighbors


# Pseudocode:
# procedure 2optSwap(route, v1, v2) {
#     1. take route[start] to route[v1] and add them in order to new_route
#     2. take route[v1+1] to route[v2] and add them in reverse order to new_route
#     3. take route[v2+1] to route[start] and add them in order to new_route
#     return new_route;
# }
def two_opt_neighborhood(path, print_neighbors=False):
    """
    Generates the 2-opt neighborhood for a given path in the Traveling Salesman Problem (TSP).
    The 2-opt neighborhood is created by reversing the order of nodes between two indices in the path.
    This function generates all possible 2-opt neighbors by considering all pairs of indices (i, j) 
    where 1 <= i < j - 1 < len(path) - 1.
    Args:
        path (list): A list representing the current path of nodes in the TSP.
    Returns:
        list: A list of paths, each representing a neighbor obtained by a 2-opt move.
    """
    neighbors = []
    n = len(path)
    # Generate all possible 2-opt neighbors
    for i in range(1, n - 2): # i starts from 1 to avoid the start node and ends at n - 2 to avoid the second-to-last node, as the last node (typically the starting node again) cannot be swapped with any other node
        for j in range(i + 3, n - 1):  # if j started from i it would swap a node with itself, if it started from i+1 it would swap two consecutive nodes, if it started from i+2 it would swap two nodes with only one node in between, not creating a true path inversion but rather a swap
            # and ends at n - 1 to avoid the end node
            new_path = path[:i] + path[i:j+1][::-1] + path[j+1:] # From start to i {path[:i]}, then from i+1 to j in reverse order {path[i:j+1][::-1]}, and finally from j+1 to the end {path[j+1:]}
            neighbors.append(new_path)
            
    if print_neighbors:
        print_in_square("Path", path)
        print("2-opt Neighborhood:")
        for neighbor in neighbors:
            print(neighbor)
    return neighbors


def two_opt_single_neighbor(path):
    """
    Generates a single neighbor of the given path using the 2-opt algorithm.
    The 2-opt algorithm works by selecting two indices i and j in the path,
    and then reversing the order of the nodes between these two indices to
    create a new path. This is a common technique used in optimization problems
    such as the Traveling Salesman Problem (TSP) to explore the neighborhood
    of a given solution.
    Parameters:
        path (list): A list representing the current path, where each element is a node.
    Returns:
        list: A new path generated by reversing the order of nodes between two
          randomly selected indices.
    """
    n = len(path)
    # Seleziona casualmente due indici validi i e j, rispettando i vincoli di 2-opt
    i = random.randint(1, n - 3)  # i parte da 1 e termina a n-3 per evitare il primo e il penultimo nodo
    j = random.randint(i + 1, n - 2)  # j è almeno 1 posizione avanti rispetto a i e termina prima dell'ultimo nodo

    # Crea il nuovo percorso invertendo i nodi tra i e j
    new_path = path[:i] + path[i:j+1][::-1] + path[j+1:]

    return new_path
def swap_single_neighbor(path):
    """
    Generates a neighboring solution by swapping two randomly selected nodes in the given path.
    This function selects two distinct indices (excluding the first and last nodes) and swaps the nodes at these indices to create a new path.
    Args:
        path (list): A list representing the current path.
    Returns:
        list: A new path with two nodes swapped.
    Raises:
        ValueError: If the path has fewer than 4 nodes.
    """
    n = len(path)
    
    # Controlla che il percorso abbia almeno 3 nodi da poter scambiare
    if n < 4:
        raise ValueError("Il percorso è troppo corto per applicare la mossa di swap.")

    # Seleziona casualmente due indici validi per il swap
    while True:
        i = random.randint(1, n - 2)  # i può essere qualsiasi nodo eccetto il primo e l'ultimo
        j = random.randint(1, n - 2)  # j è anch'esso tra 1 e n-2
        if i != j:  # Assicura che i due indici siano diversi
            break

    # Crea una copia del percorso per effettuare lo swap
    new_path = path[:]
    new_path[i], new_path[j] = new_path[j], new_path[i]

    return new_path

if __name__ == "__main__":
    path = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 0]
    # print_in_square("Path", path)
    print("2-opt Neighborhood:")
    two_opt_neighborhood(path, print_neighbors=True)
    print("Swap Neighborhood:")
    swap_neighborhood(path, print_neighbors=True)
    print("Swap Single Neighbor:")
    print(swap_single_neighbor(path))
    print("2-opt Single Neighbor:")
    print(two_opt_single_neighbor(path))
    